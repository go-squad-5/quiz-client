
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>loadtester: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/go-squad-5/quiz-load-test/cmd/loadtester/main.go (0.0%)</option>
				
				<option value="file1">github.com/go-squad-5/quiz-load-test/internal/app/app.go (100.0%)</option>
				
				<option value="file2">github.com/go-squad-5/quiz-load-test/internal/app/config.go (100.0%)</option>
				
				<option value="file3">github.com/go-squad-5/quiz-load-test/internal/app/errors.go (100.0%)</option>
				
				<option value="file4">github.com/go-squad-5/quiz-load-test/internal/app/results.go (94.7%)</option>
				
				<option value="file5">github.com/go-squad-5/quiz-load-test/internal/app/session.go (100.0%)</option>
				
				<option value="file6">github.com/go-squad-5/quiz-load-test/internal/app/simulator.go (97.2%)</option>
				
				<option value="file7">github.com/go-squad-5/quiz-load-test/internal/app/utils.go (90.0%)</option>
				
				<option value="file8">github.com/go-squad-5/quiz-load-test/internal/quizapi/create.go (94.1%)</option>
				
				<option value="file9">github.com/go-squad-5/quiz-load-test/internal/quizapi/email.go (100.0%)</option>
				
				<option value="file10">github.com/go-squad-5/quiz-load-test/internal/quizapi/mock/mock_quizapi.go (0.0%)</option>
				
				<option value="file11">github.com/go-squad-5/quiz-load-test/internal/quizapi/quizapi.go (100.0%)</option>
				
				<option value="file12">github.com/go-squad-5/quiz-load-test/internal/quizapi/report.go (91.8%)</option>
				
				<option value="file13">github.com/go-squad-5/quiz-load-test/internal/quizapi/start.go (93.5%)</option>
				
				<option value="file14">github.com/go-squad-5/quiz-load-test/internal/quizapi/submit.go (94.1%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "runtime"
        "time"

        application "github.com/go-squad-5/quiz-load-test/internal/app"
)

func main() <span class="cov0" title="0">{
        // set the number of os threads to use for the simulation
        runtime.GOMAXPROCS(runtime.NumCPU() - 1)

        startTime := time.Now()

        app := application.NewApp()

        app.ErrorListener.Add(1)
        app.InfoLogger.Println("GO ROUTINE STARTED for listening to errors")
        go app.ListenForErrors()

        app.ResultListener.Add(1)
        app.InfoLogger.Println("GO ROUTINE STARTED for listening to results")
        go app.ListenForResults()

        app.InfoLogger.Println("Starting simulation with", app.Config.NumUsers, "users")
        app.StartSimulation()

        app.Wait.Wait()
        elapsed := time.Since(startTime)

        app.Stop()
        elapsed2 := time.Since(startTime)

        app.ResultLogger.Println(
                "Total time taken to complete all sessions concurrently: ",
                elapsed.Seconds(),
                " seconds",
        )
        app.ResultLogger.Println(
                "Total time taken by test: ",
                elapsed2.Seconds(),
                " seconds",
        )
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package app

import (
        "log"
        "os"
        "sync"

        "github.com/go-squad-5/quiz-load-test/internal/quizapi"
)

type App struct {
        Config         *Config
        Wait           *sync.WaitGroup
        QuizAPI        quizapi.IQuizAPI
        Results        chan *Session
        Errors         chan error
        ResultListener *sync.WaitGroup
        ErrorListener  *sync.WaitGroup
        InfoLogger     *log.Logger
        ErrorLogger    *log.Logger
        DebugLogger    *log.Logger
        ResultLogger   *log.Logger
}

func NewApp() *App <span class="cov8" title="1">{
        cfg := LoadConfig()

        quizApi := quizapi.NewQuizAPI(
                cfg.BaseURL,
                cfg.ReportServerBaseURL,
        )

        // create loggers
        infoLog := log.New(os.Stdout, "INFO\t", log.Ltime)
        errorLog := log.New(os.Stdout, "ERROR\t", log.Ltime)
        debugLog := log.New(os.Stdout, "DEBUG\t", log.Ltime)
        resultLog := log.New(os.Stdout, "RESULT\t", log.Ltime)

        return &amp;App{
                Config:         LoadConfig(),
                Wait:           &amp;sync.WaitGroup{},
                QuizAPI:        quizApi,
                Results:        make(chan *Session, cfg.NumUsers),
                Errors:         make(chan error),
                ResultListener: &amp;sync.WaitGroup{},
                ErrorListener:  &amp;sync.WaitGroup{},
                InfoLogger:     infoLog,
                ErrorLogger:    errorLog,
                DebugLogger:    debugLog,
                ResultLogger:   resultLog,
        }
}</span>

func (app *App) Stop() <span class="cov8" title="1">{
        // wait for the results and errors to be processed
        app.InfoLogger.Println("Waiting for results and errors to be processed...")
        close(app.Errors)
        app.ErrorListener.Wait()
        close(app.Results)
        app.ResultListener.Wait()
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package app

import (
        "os"
        "strconv"
        "strings"

        _ "github.com/joho/godotenv/autoload"
)

type Config struct {
        BaseURL             string
        ReportServerBaseURL string
        NumUsers            int
}

type Endpoints struct {
        CreateSession string
        StartQuiz     string
        SubmitQuiz    string
        GetReport     string
}

func LoadConfig() *Config <span class="cov8" title="1">{
        // load configurations from environment variables
        baseUrl := os.Getenv("BASE_URL")
        if baseUrl == "" </span><span class="cov8" title="1">{
                baseUrl = "http://localhost:8080"
        }</span>
        <span class="cov8" title="1">reportServerBaseUrl := os.Getenv("REPORT_SERVER_BASEURL")
        if reportServerBaseUrl == "" </span><span class="cov8" title="1">{
                reportServerBaseUrl = "http://localhost:8070"
        }</span>
        <span class="cov8" title="1">numUsers := os.Getenv("NUM_USERS")
        if numUsers == "" </span><span class="cov8" title="1">{
                numUsers = "10"
        }</span>

        // trim trailing slashes
        <span class="cov8" title="1">baseUrl = strings.TrimSuffix(baseUrl, "/")
        reportServerBaseUrl = strings.TrimSuffix(reportServerBaseUrl, "/")

        // convert numUsers to int
        numUsersInt, err := strconv.Atoi(numUsers)
        if err != nil </span><span class="cov8" title="1">{
                panic("Invalid NUM_USERS value, must be an integer")</span>
        }

        <span class="cov8" title="1">return &amp;Config{
                BaseURL:             baseUrl,
                ReportServerBaseURL: reportServerBaseUrl,
                NumUsers:            numUsersInt,
        }</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package app

import "fmt"

type SessionError struct {
        Session *Session
}

func (e *SessionError) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf("Session error for session ID: %s ", e.Session.ID)
}</span>

type StartSessionError struct {
        Email string
        Topic string
        err   error
}

func (e *StartSessionError) Error() string <span class="cov8" title="1">{
        return fmt.Sprint("Failed to start session for email: ", e.Email,
                " on topic: ", e.Topic, " \n Error: ", e.err, "\n")
}</span>

func (app *App) ListenForErrors() <span class="cov8" title="1">{
        defer app.ErrorListener.Done()
        defer app.InfoLogger.Println("GO ROUTINE FINISHED for listening to errors")
        for err := range app.Errors </span><span class="cov8" title="1">{
                switch e := err.(type) </span>{
                case *StartSessionError:<span class="cov8" title="1">
                        app.Results &lt;- &amp;Session{
                                ID:     "",
                                Email:  e.Email,
                                Topic:  e.Topic,
                                Status: STATUS_FAILED,
                                Error:  err,
                        }</span>
                case *SessionError:<span class="cov8" title="1">
                        app.Results &lt;- e.Session</span>
                default:<span class="cov8" title="1">
                        app.Results &lt;- &amp;Session{
                                ID:     "",
                                Status: STATUS_FAILED,
                                Error:  err,
                        }</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package app

import (
        "fmt"
        "os"
        "strconv"
        "time"
)

func (app *App) ListenForResults() <span class="cov8" title="1">{
        defer app.ResultListener.Done()
        defer app.InfoLogger.Println("GO ROUTINE FINISHED for listening to results")

        file := openResultsFile()
        defer file.Close()

        timetaken := []int64{}
        // listen for results from the simulation and log them into the file
        for result := range app.Results </span><span class="cov8" title="1">{
                // get the result log string
                logString := getResultLog(result)

                // aggregate the results time taken
                timetaken = append(timetaken, result.EndTime-result.StartTime)

                // write the log string to the file
                _, err := file.WriteString(logString)
                if err != nil </span><span class="cov0" title="0">{
                        panic("Failed to write to results file: " + err.Error())</span>
                }
        }

        <span class="cov8" title="1">summary := getSummaryLog(timetaken, app.Config.NumUsers)
        fmt.Print(summary)

        // write the summary to the file
        _, err := file.WriteString(summary)
        if err != nil </span><span class="cov0" title="0">{
                panic("Failed to write summary to results file: " + err.Error())</span>
        }
}

var tmpDirPath string = "./tmp"

func openResultsFile() *os.File <span class="cov8" title="1">{
        // create a tmp directory if it doesn't exist
        mustInitDir(tmpDirPath)

        // open the results file
        file, err := os.Create(fmt.Sprintf("%s/logs.txt", tmpDirPath))
        if err != nil </span><span class="cov0" title="0">{
                panic("Failed to create results file: " + err.Error())</span>
        }
        <span class="cov8" title="1">return file</span>
}

func getResultLog(result *Session) string <span class="cov8" title="1">{
        logString := ""
        ssid := result.ID
        if ssid == "" </span><span class="cov8" title="1">{
                logString = logString + "----------------Error while starting------------\n"
        }</span> else<span class="cov8" title="1"> {
                logString = logString + "----------------Session ID: " + ssid + "----------------\n"
        }</span>
        <span class="cov8" title="1">logString = logString + "Email: " + result.Email + "\n"
        logString = logString + "User ID: " + result.UserID + "\n"
        logString = logString + "Score: " + strconv.Itoa(result.Score) + "\n"
        logString = logString + "Status: " + string(result.Status) + "\n"
        logString = logString + "Start Time: " + time.UnixMilli(result.StartTime).Format(time.RFC3339) + "\n"
        logString = logString + "End Time: " + time.UnixMilli(result.EndTime).Format(time.RFC3339) + "\n"
        logString = logString + "Time Taken: " + strconv.FormatInt(result.EndTime-result.StartTime, 10) + " ms\n"
        logString = logString + "Questions-Answers: " + fmt.Sprintf("%v", result.Answers) + "\n"
        logString = logString + "Report: " + result.Report + "\n"
        if result.Error != nil </span><span class="cov8" title="1">{
                logString = logString + "Error: " + result.Error.Error() + "\n"
        }</span>
        <span class="cov8" title="1">if result.APIsTimeTaken != nil </span><span class="cov8" title="1">{
                logString = logString + "APIs Time Taken:\n"
                logString = logString + "Session Creation: " + strconv.FormatInt(result.APIsTimeTaken.SessionCreation, 10) + " ms\n"
                logString = logString + "Start Quiz: " + strconv.FormatInt(result.APIsTimeTaken.StartQuiz, 10) + " ms\n"
                logString = logString + "Submit Quiz: " + strconv.FormatInt(result.APIsTimeTaken.SubmitQuiz, 10) + " ms\n"
                logString = logString + "Report API: " + strconv.FormatInt(result.APIsTimeTaken.ReportAPI, 10) + " ms\n"
                logString = logString + "Email API: " + strconv.FormatInt(result.APIsTimeTaken.EmailAPI, 10) + " ms\n"
        }</span> else<span class="cov8" title="1"> {
                logString = logString + "APIs Time Taken: Not available\n"
        }</span>
        <span class="cov8" title="1">logString = logString + "-----------------------------------------------\n"
        return logString</span>
}

func getSummaryLog(timetaken []int64, numOfUsers int) string <span class="cov8" title="1">{
        var totalTime int
        for _, time := range timetaken </span><span class="cov8" title="1">{
                totalTime += int(time)
        }</span>

        <span class="cov8" title="1">averageTime := float64(totalTime) / float64(len(timetaken))

        summary := "-------------------RESULTS--------------------\n"
        summary += "Total Sessions: " + strconv.Itoa(numOfUsers) + "\n"
        summary += "Average Time Taken per session: " + strconv.FormatFloat(averageTime, 'f', 2, 64) + " milliseconds\n"
        summary += "Check ./tmp/logs.txt for all logs\n"
        summary += "-----------------------------------------------\n"

        return summary</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package app

import (
        "time"

        "github.com/go-squad-5/quiz-load-test/internal/quizapi"
)

type STATUS string

const (
        STATUS_CREATED   STATUS = "created"
        STATUS_STARTED   STATUS = "started"
        STATUS_COMPLETED STATUS = "completed"
        STATUS_FAILED    STATUS = "failed"
)

type APIsTimeTaken struct {
        SessionCreation int64
        StartQuiz       int64
        SubmitQuiz      int64
        ReportAPI       int64
        EmailAPI        int64
}

func NewAPIsTimeTaken() *APIsTimeTaken <span class="cov8" title="1">{
        return &amp;APIsTimeTaken{}
}</span>

func (a *APIsTimeTaken) SetSessionCreationTime(timetaken int64) <span class="cov8" title="1">{
        a.SessionCreation = timetaken
}</span>

func (a *APIsTimeTaken) SetStartQuizTime(timetaken int64) <span class="cov8" title="1">{
        a.StartQuiz = timetaken
}</span>

func (a *APIsTimeTaken) SetSubmitQuizTime(timetaken int64) <span class="cov8" title="1">{
        a.SubmitQuiz = timetaken
}</span>

func (a *APIsTimeTaken) SetReportAPITime(timetaken int64) <span class="cov8" title="1">{
        a.ReportAPI = timetaken
}</span>

func (a *APIsTimeTaken) SetEmailAPITime(timetaken int64) <span class="cov8" title="1">{
        a.EmailAPI = timetaken
}</span>

type Session struct {
        ID            string
        Email         string
        Topic         string
        UserID        string
        StartTime     int64
        EndTime       int64
        Question      []quizapi.Question
        Answers       []quizapi.Answer
        Score         int
        Report        string
        Status        STATUS
        Error         error
        CreatedAt     int64
        APIsTimeTaken *APIsTimeTaken
}

func NewSession(email, topic string, aPIsTimeTaken *APIsTimeTaken) *Session <span class="cov8" title="1">{
        return &amp;Session{
                ID:            "",
                UserID:        "user_" + email,
                Email:         email,
                Topic:         topic,
                Status:        STATUS_STARTED,
                StartTime:     time.Now().UnixMilli(),
                EndTime:       0,
                Answers:       []quizapi.Answer{},
                Score:         0,
                CreatedAt:     time.Now().UnixMilli(),
                APIsTimeTaken: aPIsTimeTaken,
        }
}</span>

func (s *Session) SetSession(ssid string) <span class="cov8" title="1">{
        s.ID = ssid
}</span>

func (s *Session) SetStatus(status STATUS) <span class="cov8" title="1">{
        s.Status = status
}</span>

func (s *Session) SetStartTime(timestamp time.Time) <span class="cov8" title="1">{
        s.StartTime = timestamp.UnixMilli()
}</span>

func (s *Session) SetEndTime(timestamp time.Time) <span class="cov8" title="1">{
        s.EndTime = timestamp.UnixMilli()
}</span>

func (s *Session) SetAnswers(answers []quizapi.Answer) <span class="cov8" title="1">{
        s.Answers = answers
}</span>

func (s *Session) SetScore(score int) <span class="cov8" title="1">{
        s.Score = score
}</span>

func (s *Session) SetReport(report string) <span class="cov8" title="1">{
        s.Report = report
}</span>

func (s *Session) SetError(err error) <span class="cov8" title="1">{
        s.Error = err
}</span>

func (s *Session) SetQuestions(questions []quizapi.Question) <span class="cov8" title="1">{
        s.Question = questions
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package app

import (
        "fmt"
        "math/rand"
        "sync"
        "time"

        "github.com/go-squad-5/quiz-load-test/internal/quizapi"
)

func (app *App) StartSimulation() <span class="cov8" title="1">{
        for i := range app.Config.NumUsers </span><span class="cov8" title="1">{
                numEmails, numTopics := getNumberOfEmailsAndTopics()
                email := EMAILS[i%numEmails]
                topic := TOPICS[i%numTopics]
                app.Wait.Add(1)
                app.InfoLogger.Println("GO ROUTINE started for user simulation: ", email, "on topic:", topic)
                go app.SimulateUser(email, topic)
        }</span>
}

func (app *App) SimulateUser(email, topic string) <span class="cov8" title="1">{
        defer func() </span><span class="cov8" title="1">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        app.ErrorLogger.Println("Recovered from panic in user", email, ":", r)
                }</span>
                <span class="cov8" title="1">app.InfoLogger.Println("GO ROUTINE FINISHED for user simulation:", email, "on topic:", topic)
                app.Wait.Done()</span>
        }()
        <span class="cov8" title="1">app.InfoLogger.Printf("Simulating user action for email: %s, topic: %s\n", email, topic)

        // create session struct
        aPIsTimeTaken := NewAPIsTimeTaken()
        session := NewSession(email, topic, aPIsTimeTaken)

        ssid, createTimeTaken, err := app.callCreateSession(email, topic)
        aPIsTimeTaken.SetSessionCreationTime(createTimeTaken)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">session.SetSession(ssid)

        questions, startQuizTimeTaken, err := app.callStartQuiz(ssid, topic, session)
        aPIsTimeTaken.SetStartQuizTime(startQuizTimeTaken)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">session.SetQuestions(questions)

        // mark random answers to questions
        if err := app.markRandomAnswers(questions, session); err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">score, submitTimeTaken, err := app.callSubmitQuiz(ssid, session)
        aPIsTimeTaken.SetSubmitQuizTime(submitTimeTaken)
        session.SetScore(score)

        // call report and email apis concurrently
        app.callReportAndEmailAPIs(session)

        // end session
        session.SetEndTime(time.Now())
        session.SetStatus(STATUS_COMPLETED)

        app.InfoLogger.Printf("Session completed for email: %s, topic: %s, session ID: %s, score: %d\n Sending session data to the results channel to log.", email, topic, ssid, score)
        app.Results &lt;- session</span>
}

func (app *App) callCreateSession(email, topic string) (string, int64, error) <span class="cov8" title="1">{
        app.InfoLogger.Println("Sending Request to create session for email:", email, "on topic:", topic)
        createStart := time.Now()
        ssid, err := app.QuizAPI.CreateSession(email, topic)
        createEnd := time.Now()
        app.InfoLogger.Printf("Session created for email: %s, topic: %s, session ID: %s\n", email, topic, ssid)
        if err != nil </span><span class="cov8" title="1">{
                app.ErrorLogger.Printf("Error creating session for email: %s, topic: %s, error: %v\n", email, topic, err)
                app.Errors &lt;- &amp;StartSessionError{
                        Email: email,
                        Topic: topic,
                        err:   err,
                }
                return "", getTimeDiff(createStart, createEnd), err
        }</span>
        <span class="cov8" title="1">return ssid, getTimeDiff(createStart, createEnd), nil</span>
}

func (app *App) callStartQuiz(ssid, topic string, session *Session) ([]quizapi.Question, int64, error) <span class="cov8" title="1">{
        if session == nil </span><span class="cov8" title="1">{
                return nil, 0, fmt.Errorf("sesssion should be non-nil value")
        }</span>
        <span class="cov8" title="1">app.InfoLogger.Println("Sending Request to start quiz for session ID:", ssid, "on topic:", topic)
        startQuizStart := time.Now()
        questions, err := app.QuizAPI.StartQuiz(ssid, topic)
        startQuizEnd := time.Now()
        app.InfoLogger.Printf("Got questions for session ID: %s, topic: %s, questions: %d\n", ssid, topic, len(questions))
        if err != nil </span><span class="cov8" title="1">{
                app.ErrorLogger.Printf("Error starting quiz for session ID: %s, topic: %s, error: %v\n", ssid, topic, err)
                session.SetError(err)
                session.SetStatus(STATUS_FAILED)
                session.SetEndTime(time.Now())
                app.Errors &lt;- &amp;SessionError{
                        Session: session,
                }
                return nil, getTimeDiff(startQuizStart, startQuizEnd), err
        }</span>
        <span class="cov8" title="1">app.InfoLogger.Printf("Quiz started for session ID: %s, topic: %s, questions: %d\n", ssid, topic, len(questions))
        return questions, getTimeDiff(startQuizStart, startQuizEnd), nil</span>
}

func (app *App) markRandomAnswers(questions []quizapi.Question, session *Session) error <span class="cov8" title="1">{
        if session == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("sesssion should be non-nil value")
        }</span>
        <span class="cov8" title="1">if questions == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("questions slice should be non-nil")
        }</span>
        <span class="cov8" title="1">answers := make([]quizapi.Answer, 0, len(questions))
        for _, question := range questions </span><span class="cov8" title="1">{
                numOptions := len(question.Options)
                if numOptions == 0 </span><span class="cov8" title="1">{
                        app.ErrorLogger.Println("No options available for question ID:", question.ID)
                        session.SetError(fmt.Errorf("no options available for question ID: %s", question.ID))
                        session.SetStatus(STATUS_FAILED)
                        session.SetEndTime(time.Now())
                        app.Errors &lt;- &amp;SessionError{
                                Session: session,
                        }
                        return session.Error
                }</span>
                <span class="cov8" title="1">index := rand.Intn(numOptions) // random index
                answers = append(answers, quizapi.Answer{
                        QuestionID: question.ID,
                        Answer:     question.Options[index],
                })</span>
        }
        <span class="cov8" title="1">session.SetAnswers(answers)
        return nil</span>
}

func (app *App) callSubmitQuiz(ssid string, session *Session) (int, int64, error) <span class="cov8" title="1">{
        if session == nil </span><span class="cov8" title="1">{
                return 0, 0, fmt.Errorf("sesssion should be non-nil value")
        }</span>
        <span class="cov8" title="1">app.InfoLogger.Println("Sending Request to submit quiz for session ID:", ssid)
        submitStart := time.Now()
        score, err := app.QuizAPI.SubmitQuiz(ssid, session.Answers)
        submitEnd := time.Now()
        app.InfoLogger.Printf("Quiz submitted for session ID: %s, score: %d\n", ssid, score)
        if err != nil </span><span class="cov8" title="1">{
                app.ErrorLogger.Printf("Error submitting quiz for session ID: %s, error: %v\n", ssid, err)
                session.SetStatus(STATUS_FAILED)
                session.SetError(err)
                session.SetEndTime(submitEnd)
                app.Errors &lt;- &amp;SessionError{
                        Session: session,
                }
                return 0, getTimeDiff(submitStart, submitEnd), err
        }</span>
        <span class="cov8" title="1">return score, getTimeDiff(submitStart, submitEnd), nil</span>
}

func (app *App) callReportAndEmailAPIs(session *Session) <span class="cov8" title="1">{
        if session == nil </span><span class="cov8" title="1">{
                panic("session should be non-nil value")</span>
        }

        <span class="cov8" title="1">wg := &amp;sync.WaitGroup{}

        wg.Add(1)
        app.InfoLogger.Println("GO ROUTINE Started to get report for session ID:", session.ID)
        go func() </span><span class="cov8" title="1">{
                defer wg.Done()
                defer app.InfoLogger.Println("GO ROUTINE FINISHED for getting report for session ID:", session.ID)
                // Get the report for the session
                report, reportTimeTaken, _ := app.callGetReport(session)
                session.APIsTimeTaken.SetReportAPITime(reportTimeTaken)
                session.SetReport(report)
        }</span>()

        <span class="cov8" title="1">wg.Add(1)
        app.InfoLogger.Println("GO ROUTINE Started to get email report for session ID:", session.ID)
        go func() </span><span class="cov8" title="1">{
                defer wg.Done()
                defer app.InfoLogger.Println("GO ROUTINE FINISHED for getting email report for session ID:", session.ID)
                // Do email request
                timeTaken, _ := app.callGetEmail(session)
                session.APIsTimeTaken.SetEmailAPITime(timeTaken)
        }</span>()

        <span class="cov8" title="1">wg.Wait()</span>
}

func (app *App) callGetReport(session *Session) (string, int64, error) <span class="cov8" title="1">{
        if session == nil </span><span class="cov8" title="1">{
                return "", 0, fmt.Errorf("sesssion should be non-nil value")
        }</span>
        <span class="cov8" title="1">app.InfoLogger.Println("Sending Request to get report for session ID:", session.ID)
        reportStart := time.Now()
        report, err := app.QuizAPI.GetReport(session.ID)
        reportEnd := time.Now()
        app.InfoLogger.Printf("Report received for session ID: %s, report: %+v\n", session.ID, report)
        if err != nil </span><span class="cov8" title="1">{
                session.SetError(err)
                session.SetStatus(STATUS_FAILED)
                session.SetEndTime(time.Now())
                app.ErrorLogger.Printf("Error getting report for session ID: %s, error: %v\n", session.ID, err)
                app.Errors &lt;- &amp;SessionError{
                        Session: session,
                }
                return "", getTimeDiff(reportStart, reportEnd), err
        }</span>
        <span class="cov8" title="1">return report, getTimeDiff(reportStart, reportEnd), nil</span>
}

func (app *App) callGetEmail(session *Session) (int64, error) <span class="cov8" title="1">{
        if session == nil </span><span class="cov8" title="1">{
                return 0, fmt.Errorf("sesssion should be non-nil value")
        }</span>
        <span class="cov8" title="1">app.InfoLogger.Println("Sending Request to get email report for session ID:", session.ID)
        emailStart := time.Now()
        _, err := app.QuizAPI.GetEmailReport(session.ID)
        emailEnd := time.Now()
        app.InfoLogger.Printf("Email Request Successful for session ID: %s\n", session.ID)
        if err != nil </span><span class="cov8" title="1">{
                session.SetError(err)
                session.SetStatus(STATUS_FAILED)
                session.SetEndTime(emailEnd)
                app.Errors &lt;- &amp;SessionError{
                        Session: session,
                }
                return getTimeDiff(emailStart, emailEnd), err
        }</span>
        <span class="cov8" title="1">return getTimeDiff(emailStart, emailEnd), nil</span>
}

// NOTE: FakeUserAction can be used instead of SimulateUser to run the application
//
// func (app *App) FakeUserAction(email, topic string) {
//         defer app.Wait.Done()
//         log.Printf("Simulating user action for email: %s, topic: %s\n", email, topic)
//         startTime := time.Now()
//         time.Sleep(time.Duration(rand.Intn(2)+1) * time.Second)
//         endTime := time.Now()
//
//         app.Results &lt;- &amp;Session{
//                 ID:        "somereandomstring",
//                 UserID:    "user_" + email,
//                 Email:     email,
//                 Topic:     topic,
//                 Status:    STATUS_COMPLETED,
//                 StartTime: startTime.UnixMilli(),
//                 EndTime:   endTime.UnixMilli(),
//         }
// }
</pre>
		
		<pre class="file" id="file7" style="display: none">package app

import (
        "os"
        "time"
)

var EMAILS []string = []string{
        "test1@example.com",
        "test2@example.com",
        "test3@example.com",
        "test4@example.com",
        "test5@example.com",
        "test6@example.com",
        "test7@example.com",
        "test8@example.com",
        "test9@example.com",
        "test10@example.com",
        "test11@example.com",
        "test12@example.com",
        "test13@example.com",
        "test14@example.com",
        "test15@example.com",
        "test16@example.com",
        "test17@example.com",
        "test18@example.com",
        "test19@example.com",
        "test20@example.com",
        "test21@example.com",
        "test22@example.com",
        "test23@example.com",
        "test24@example.com",
        "test25@example.com",
        "test26@example.com",
        "test27@example.com",
        "test28@example.com",
        "test29@example.com",
        "test30@example.com",
}

var TOPICS []string = []string{
        "go",
        "java",
        "python",
        "c",
        "c++",
        "zig",
        "rust",
        "ocaml",
        "javascript",
        "ruby",
        "kotlin",
        "lua",
        "shell",
}

func getNumberOfEmailsAndTopics() (emails int, topics int) <span class="cov8" title="1">{
        emails = len(EMAILS)
        topics = len(TOPICS)
        return emails, topics
}</span>

// getTimeDiff return difference in milli seconds between t2 and t1 (t2 - t1)
func getTimeDiff(t1, t2 time.Time) int64 <span class="cov8" title="1">{
        return int64(t2.Sub(t1).Milliseconds())
}</span>

// creates a given directory if it doesn't exist
func mustInitDir(dirPath string) <span class="cov8" title="1">{
        if _, err := os.Stat(dirPath); err != nil &amp;&amp; os.IsNotExist(err) </span><span class="cov8" title="1">{
                err := os.Mkdir(dirPath, 0755)
                if err != nil </span><span class="cov8" title="1">{
                        panic("Failed to create directory: " + err.Error())</span>
                }
        } else<span class="cov8" title="1"> if err != nil </span><span class="cov0" title="0">{
                panic("Failed to check dir stat")</span>
        }
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package quizapi

import (
        "bytes"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "strings"
)

type CreateSessionAPIRequest struct {
        Email string `json:"email"`
        Topic string `json:"topic"`
}

type CreateSessionAPIResponse struct {
        SessionID string `json:"session_id"`
        Message   string `json:"message"`
}

func (q *QuizAPI) CreateSession(email, topic string) (string, error) <span class="cov8" title="1">{
        if err := validateCreateSessionInputs(email, topic); err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov8" title="1">body, err := buildCreateSessionAPIRequest(email, topic)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // send the request
        <span class="cov8" title="1">resp, err := q.client.Post(
                q.endpoints.createSession,
                "application/json",
                body,
        )
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        if err = validateCreateSessionAPIResponseStatus(resp); err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov8" title="1">return parseCreateSessionAPIResponse(resp.Body)</span>
}

func isValidEmail(email string) bool <span class="cov8" title="1">{
        if i := strings.Index(email, "@"); len(email) &lt; 3 || i &lt; 1 || (i != -1 &amp;&amp; !strings.Contains(email[i:], ".")) </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return true</span>
}

func validateCreateSessionInputs(email, topic string) error <span class="cov8" title="1">{
        if email == "" || topic == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("email and topic are required")
        }</span>
        <span class="cov8" title="1">if !isValidEmail(email) </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid email format: %s", email)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func buildCreateSessionAPIRequest(email, topic string) (*bytes.Buffer, error) <span class="cov8" title="1">{
        req := CreateSessionAPIRequest{
                Email: email,
                Topic: topic,
        }
        body, err := json.Marshal(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return bytes.NewBuffer(body), nil</span>
}

func validateCreateSessionAPIResponseStatus(resp *http.Response) error <span class="cov8" title="1">{
        if resp.StatusCode != http.StatusOK </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to create session, status code: %d", resp.StatusCode)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func parseCreateSessionAPIResponse(body io.ReadCloser) (string, error) <span class="cov8" title="1">{
        var response CreateSessionAPIResponse
        if err := json.NewDecoder(body).Decode(&amp;response); err != nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("failed to decode response: %v", err)
        }</span>
        <span class="cov8" title="1">if response.SessionID == "" </span><span class="cov8" title="1">{
                return "", fmt.Errorf("session ID is empty in response: %s", response.Message)
        }</span>
        <span class="cov8" title="1">return response.SessionID, nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package quizapi

import (
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "net/http"
)

type GetEmailReportErrorResponse struct {
        Message    string `json:"message"`
        StatusCode int    `json:"statusCode"`
}

func (q *QuizAPI) GetEmailReport(sessionID string) (string, error) <span class="cov8" title="1">{
        reqUrl := buildGetEmailReportAPIURL(q.endpoints.getEmailReport, sessionID)

        // send the request
        resp, err := q.client.Post(reqUrl, "application/json", nil)
        if err != nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("failed to send request to get email report: %w", err)
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        if err := validateGetEmailReportResponseStatus(resp); err != nil </span><span class="cov8" title="1">{
                errResp, err := parseGetEmailReportErrorResponse(resp.Body)
                if err != nil </span><span class="cov8" title="1">{
                        return "", fmt.Errorf("failed to parse error response: %w", err)
                }</span>
                <span class="cov8" title="1">return "", errors.New(errResp)</span>
        }

        <span class="cov8" title="1">return "Email report request accepted", nil</span>
}

func buildGetEmailReportAPIURL(endpoint, sessionID string) string <span class="cov8" title="1">{
        return fmt.Sprintf(endpoint, sessionID)
}</span>

func parseGetEmailReportErrorResponse(body io.ReadCloser) (string, error) <span class="cov8" title="1">{
        var errorResp GetEmailReportErrorResponse
        if err := json.NewDecoder(body).Decode(&amp;errorResp); err != nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("failed to parse error response body: %w", err)
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("failed to get email report, status code: %d, message: %s", errorResp.StatusCode, errorResp.Message), nil</span>
}

func validateGetEmailReportResponseStatus(resp *http.Response) error <span class="cov8" title="1">{
        if resp.StatusCode != http.StatusAccepted </span><span class="cov8" title="1">{
                return fmt.Errorf("not accepted")
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package mock

import (
        "github.com/go-squad-5/quiz-load-test/internal/quizapi"
        "github.com/stretchr/testify/mock"
)

type MockQuizAPI struct {
        mock.Mock
}

func (m *MockQuizAPI) CreateSession(email, topic string) (string, error) <span class="cov0" title="0">{
        args := m.Called(email, topic)
        return args.String(0), args.Error(1)
}</span>

func (m *MockQuizAPI) StartQuiz(sessionId, topic string) ([]quizapi.Question, error) <span class="cov0" title="0">{
        args := m.Called(sessionId, topic)
        return args.Get(0).([]quizapi.Question), args.Error(1)
}</span>

func (m *MockQuizAPI) SubmitQuiz(sessionId string, answers []quizapi.Answer) (int, error) <span class="cov0" title="0">{
        args := m.Called(sessionId, answers)
        return args.Int(0), args.Error(1)
}</span>

func (m *MockQuizAPI) GetReport(sessionId string) (string, error) <span class="cov0" title="0">{
        args := m.Called(sessionId)
        return args.String(0), args.Error(1)
}</span>

func (m *MockQuizAPI) GetEmailReport(sessionId string) (string, error) <span class="cov0" title="0">{
        args := m.Called(sessionId)
        return args.String(0), args.Error(1)
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package quizapi

import (
        "net/http"
        "time"
)

type IQuizAPI interface {
        CreateSession(email, topic string) (string, error)
        StartQuiz(sessionId, topic string) ([]Question, error)
        SubmitQuiz(sessionId string, answers []Answer) (int, error) // Score, error
        GetReport(sessionId string) (string, error)
        GetEmailReport(sessionId string) (string, error)
}

type QuizAPI struct {
        client    *http.Client
        endpoints endpoints
}

type endpoints struct {
        createSession  string
        startQuiz      string
        submitQuiz     string
        getReport      string
        getEmailReport string
}

func NewQuizAPI(baseUrl, reportServerBaseUrl string) *QuizAPI <span class="cov8" title="1">{
        return &amp;QuizAPI{
                client: &amp;http.Client{
                        Timeout: 60 * time.Second,
                },
                endpoints: endpoints{
                        createSession:  baseUrl + "/session/create",
                        startQuiz:      baseUrl + "/quiz/start",
                        submitQuiz:     baseUrl + "/quiz/submit",
                        getReport:      reportServerBaseUrl + "/sessions/%s/report",
                        getEmailReport: reportServerBaseUrl + "/sessions/%s/email-report",
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package quizapi

import (
        "encoding/base64"
        "encoding/json"
        "errors"

        "fmt"
        "io"
        "net/http"
        "os"
)

type GetReportResponseData struct {
        DocumentID    string `json:"documentId"`
        FileName      string `json:"fileName"`
        DownloadURL   string `json:"downloadUrl"`
        ExpiresAt     string `json:"expiresAt"`
        ContentBase64 string `json:"contentBase64"`
}

type GetReportResponse struct {
        Success bool                  `json:"success"`
        Message string                `json:"message"`
        Data    GetReportResponseData `json:"data"`
}

type GetReportErrorResponse struct {
        StatusCode int    `json:"statusCode"`
        Message    string `json:"message"`
}

func (q *QuizAPI) GetReport(sessionID string) (string, error) <span class="cov8" title="1">{
        reqUrl := buildGetReportAPIURL(q.endpoints.getReport, sessionID)

        resp, err := q.client.Get(reqUrl)
        if err != nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("failed to get report: %w", err)
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        if err := validateGetReportResponseStatus(resp); err != nil </span><span class="cov8" title="1">{
                errResp, err := parseGetReportErrorResponse(resp.Body)
                if err != nil </span><span class="cov8" title="1">{
                        return "", fmt.Errorf("failed to parse error response: %w", err)
                }</span>
                <span class="cov8" title="1">return "", errors.New(errResp)</span>
        }

        <span class="cov8" title="1">file, filePath, err := openSessionReportFile(sessionID)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to open session report file: %w", err)
        }</span>
        <span class="cov8" title="1">defer file.Close()

        if err := saveResponseToFile(resp, file); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">return filePath, nil</span>
}

func buildGetReportAPIURL(endpoint, sessionID string) string <span class="cov8" title="1">{
        return fmt.Sprintf(endpoint, sessionID)
}</span>

func validateGetReportResponseStatus(resp *http.Response) error <span class="cov8" title="1">{
        if resp.StatusCode != http.StatusOK </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to get report, status code: %d", resp.StatusCode)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func parseGetReportErrorResponse(body io.ReadCloser) (string, error) <span class="cov8" title="1">{
        var errorResp GetReportErrorResponse
        if err := json.NewDecoder(body).Decode(&amp;errorResp); err != nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("failed to parse error response body: %w", err)
        }</span>
        <span class="cov8" title="1">if errorResp.StatusCode == 0 </span><span class="cov8" title="1">{
                return "", fmt.Errorf("error response should have a valid statusCode")
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("failed to get report, status code: %d, message: %s", errorResp.StatusCode, errorResp.Message), nil</span>
}

var reportsDirPath string = "./tmp/reports"

func openSessionReportFile(sessionId string) (*os.File, string, error) <span class="cov8" title="1">{
        // create a tmp directory if it doesn't exist
        if _, err := os.Stat(reportsDirPath); os.IsNotExist(err) </span><span class="cov8" title="1">{
                err := os.MkdirAll(reportsDirPath, 0755)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, "", fmt.Errorf("failed to create tmp/reports directory: %w", err)
                }</span>
        }

        <span class="cov8" title="1">filePath := fmt.Sprintf("%s/%s_report.pdf", reportsDirPath, sessionId)
        file, err := os.Create(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, "", fmt.Errorf("failed to create file: %w", err)
        }</span>

        <span class="cov8" title="1">return file, filePath, nil</span>
}

func saveResponseToFile(resp *http.Response, file *os.File) error <span class="cov8" title="1">{
        if _, err := io.Copy(file, resp.Body); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to write file: %w", err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// NOTE: if json - base64 response (as per API docs, we have two possible response formats)
//
// respJson, err := parseJsonGetReportResponse(resp.Body)
// if err != nil {
//   return "", fmt.Errorf("failed to parse JSON response: %w", err)
// }
//
// if err := decodeAndSaveBase64Response(respJson.Data.ContentBase64, file); err != nil {
//          return "", fmt.Errorf("failed to parse base64 response: %w", err)
// }

func parseJsonGetReportResponse(respBody io.ReadCloser) (GetReportResponse, error) <span class="cov8" title="1">{
        var reportResp GetReportResponse
        if err := json.NewDecoder(respBody).Decode(&amp;reportResp); err != nil </span><span class="cov8" title="1">{
                return GetReportResponse{}, fmt.Errorf("failed to parse response body: %w", err)
        }</span>
        <span class="cov8" title="1">return reportResp, nil</span>
}

func decodeAndSaveBase64Response(base64String string, file *os.File) error <span class="cov8" title="1">{
        binaryData, err := base64.StdEncoding.DecodeString(base64String)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to decode base64 string: %w", err)
        }</span>
        <span class="cov8" title="1">if _, err := file.Write(binaryData); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to write file: %w", err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package quizapi

import (
        "bytes"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
)

type StartQuizAPIRequest struct {
        SessionID string `json:"ssid"`
        Topic     string `json:"topic"`
}

type StartQuizAPIResponse struct {
        SessionID string     `json:"session_id"`
        Questions []Question `json:"questions"`
}

type Question struct {
        ID       string   `json:"ques_id"`
        Question string   `json:"question"`
        Options  []string `json:"options"`
}

func (q *QuizAPI) StartQuiz(sessionId, topic string) ([]Question, error) <span class="cov8" title="1">{
        if err := validateStartQuizInputs(sessionId, topic); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">body, err := buildStartQuizRequestBody(sessionId, topic)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Send Request
        <span class="cov8" title="1">resp, err := q.client.Post(
                q.endpoints.startQuiz,
                "application/json",
                body,
        )
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        if err := validateStartQuizAPIStatus(resp); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return parseStartQuizResponse(resp.Body)</span>
}

func validateStartQuizInputs(sessionId, topic string) error <span class="cov8" title="1">{
        if sessionId == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("SessionID is required")
        }</span>
        <span class="cov8" title="1">if topic == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("Topic is required")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func buildStartQuizRequestBody(sessionId, topic string) (*bytes.Buffer, error) <span class="cov8" title="1">{
        req := StartQuizAPIRequest{
                SessionID: sessionId,
                Topic:     topic,
        }
        body, err := json.Marshal(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return bytes.NewBuffer(body), nil</span>
}

func validateStartQuizAPIStatus(resp *http.Response) error <span class="cov8" title="1">{
        if resp.StatusCode != http.StatusOK </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to start quiz, status code: %d", resp.StatusCode)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func parseStartQuizResponse(body io.ReadCloser) ([]Question, error) <span class="cov8" title="1">{
        var response StartQuizAPIResponse
        if err := json.NewDecoder(body).Decode(&amp;response); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to decode response: %v", err)
        }</span>
        <span class="cov8" title="1">if response.SessionID == "" || len(response.Questions) == 0 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid response: session_id or questions are empty")
        }</span>
        <span class="cov8" title="1">return response.Questions, nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package quizapi

import (
        "bytes"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
)

type Answer struct {
        QuestionID string `json:"ques_id"`
        Answer     string `json:"answer"`
}

type SubmitQuizAPIRequest struct {
        SessionID string   `json:"session_id"`
        Answers   []Answer `json:"answers"`
}

type SubmitQuizAPIResponse struct {
        Score int `json:"score"`
}

func (q *QuizAPI) SubmitQuiz(sessionId string, answers []Answer) (int, error) <span class="cov8" title="1">{
        if err := validateSubmitQuizInputs(sessionId, answers); err != nil </span><span class="cov8" title="1">{
                return 0, err
        }</span>

        <span class="cov8" title="1">body, err := buildSubmitQuizAPIRequestBody(sessionId, answers)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to build request body: %w", err)
        }</span>

        <span class="cov8" title="1">resp, err := q.client.Post(
                q.endpoints.submitQuiz,
                "application/json",
                body,
        )
        if err != nil </span><span class="cov8" title="1">{
                return 0, err
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        if err := validateSubmitQuizAPIStatus(resp); err != nil </span><span class="cov8" title="1">{
                return 0, err
        }</span>

        <span class="cov8" title="1">return parseSubmitQuizAPIResponse(resp.Body)</span>
}

func validateSubmitQuizInputs(sessionId string, answers []Answer) error <span class="cov8" title="1">{
        if sessionId == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("SessionID is required")
        }</span>
        <span class="cov8" title="1">if len(answers) == 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("at least one answer is required")
        }</span>
        <span class="cov8" title="1">for _, answer := range answers </span><span class="cov8" title="1">{
                if answer.QuestionID == "" || answer.Answer == "" </span><span class="cov8" title="1">{
                        return fmt.Errorf("each answer must have a question ID and an answer")
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func buildSubmitQuizAPIRequestBody(sessionId string, answers []Answer) (*bytes.Buffer, error) <span class="cov8" title="1">{
        req := SubmitQuizAPIRequest{
                SessionID: sessionId,
                Answers:   answers,
        }
        body, err := json.Marshal(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal request body: %w", err)
        }</span>
        <span class="cov8" title="1">return bytes.NewBuffer(body), nil</span>
}

func validateSubmitQuizAPIStatus(resp *http.Response) error <span class="cov8" title="1">{
        if resp.StatusCode != http.StatusOK </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to submit quiz, status code: %d", resp.StatusCode)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func parseSubmitQuizAPIResponse(body io.ReadCloser) (int, error) <span class="cov8" title="1">{
        var response SubmitQuizAPIResponse
        if err := json.NewDecoder(body).Decode(&amp;response); err != nil </span><span class="cov8" title="1">{
                return 0, fmt.Errorf("failed to decode response: %w", err)
        }</span>
        <span class="cov8" title="1">if response.Score &lt; 0 </span><span class="cov8" title="1">{
                return 0, fmt.Errorf("invalid score received: %d", response.Score)
        }</span>
        <span class="cov8" title="1">return response.Score, nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
